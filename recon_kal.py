import tkinter
import customtkinter as ctk
import requests
import dns.resolver
import json
from bs4 import BeautifulSoup
import re
import sys
import threading
import queue
import os
import time 
import concurrent.futures

# --- Tee Class and QueueHandler (No changes) ---
class Tee:
    """A helper class to redirect print output to multiple streams (e.g., file and GUI)."""
    def __init__(self, *files):
        self.files = files
    def write(self, obj):
        for f in self.files:
            f.write(obj)
            f.flush()
    def flush(self):
        for f in self.files:
            f.flush()

class QueueHandler:
    """A handler to redirect stdout to a thread-safe queue for the GUI."""
    def __init__(self, queue_instance):
        self.queue = queue_instance
    def write(self, text):
        self.queue.put(text)
    def flush(self):
        pass

# --- WAF, IP & Whois Functions (No changes) ---
WAF_FINGERPRINTS = {
    'Cloudflare': {'headers': {'server': r'cloudflare', 'cf-ray': r'.*'},'cookies': {'__cfduid': r'.*', 'cf_clearance': r'.*'},'body': r'<title>Just a moment...</title>|cloudflare-challenge|Checking your browser before accessing'},
    'Sucuri': {'headers': {'server': r'Sucuri/Cloudproxy', 'x-sucuri-id': r'.*'},'cookies': {'sucuri_cloudproxy_uuid_': r'.*'},'body': r'Access Denied - Sucuri Website Firewall|blacklisted by Sucuri'},
    'Akamai': {'headers': {'server': r'AkamaiGHost', 'x-akamai-transformed': r'.*'},'body': r'The requested URL "[^"]+" is unacceptable|AkamaiGHost'},
    'AWS WAF': {'headers': {'server': r'awselb/2.0|AWS'},'cookies': {'AWSALB': r'.*', 'AWSALBCORS': r'.*'},'body': r'<h1>403 Forbidden</h1>.+Request blocked'},
    'Imperva': {'headers': {'x-iinfo': r'.*'},'cookies': {'incap_ses_': r'.*', 'visid_incap_': r'.*'},'body': r'/_Incapsula_Resource|Powered by Incapsula'},
    'F5 BIG-IP': {'headers': {'server': r'BigIP|BIG-IP'},'cookies': {'BIGipServer': r'.*', 'TS[a-zA-Z0-9]{3,8}=': r'.*'},'body': r'the BIG-IP system has detected a problem'},
    'Barracuda': {'headers': {'server': r'BarracudaHTTPProxy'},'cookies': {'barracuda_ci_csrf_token': r'.*'},'body': r'Barracuda Web Application Firewall|Powered by Barracuda Networks'},
    'FortiWeb': {'headers': {},'cookies': {'FORTIWAFSID': r'.*'},'body': r'Web Page Blocked|powered by FortiGuard'},
    'ModSecurity': {'headers': {'server': r'mod_security'},'body': r'This error was generated by Mod_Security|Mod Security Action'},
    'Citrix NetScaler': {'headers': {},'cookies': {'ns_af': r'.*', 'citrix_ns_id': r'.*'},'body': r'<title>Application Firewall Block Page</title>'},
    'Radware AppWall': {'headers': {},'cookies': {'rdware_rw_lb_p': r'.*'},'body': r'CloudWebSec.Radware'},
    'Wallarm': {'headers': {'server': r'wallarm-nginx'},'body': r'nginxlb/wallarm'}
}

def detect_waf(domain, verbose=True):
    if verbose: print(f"\n--- [WAF Detection] Checking for WAF on {domain} ---")
    payloads = {"xss": "/?s=<script>alert(1)</script>","sqli": "/?id=1'\" AND 1=1 UNION SELECT 1,2,3--","traversal": "/?file=../../../../etc/passwd"}
    headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'}
    try:
        normal_response = requests.get(f"https://{domain}", headers=headers, timeout=10, allow_redirects=True)
        for waf_name, fp in WAF_FINGERPRINTS.items():
            if _match_fingerprint(normal_response, fp): return waf_name
        for attack_type, payload in payloads.items():
            try:
                malicious_response = requests.get(f"https://{domain}{payload}", headers=headers, timeout=10, allow_redirects=True)
                if normal_response.status_code == 200 and malicious_response.status_code in [403, 406, 429, 501]:
                    if verbose: print(f"[i] Generic WAF behavior detected: Normal request got 200, but {attack_type.upper()} request got {malicious_response.status_code}.")
                    return "Generic WAF/Blocking Mechanism"
                for waf_name, fp in WAF_FINGERPRINTS.items():
                    if _match_fingerprint(malicious_response, fp): return waf_name
            except requests.exceptions.RequestException:
                if verbose: print(f"[i] Request with {attack_type.upper()} payload failed. This could indicate a WAF.")
                continue
    except requests.exceptions.RequestException as e:
        if verbose: print(f"[!] A network error occurred during WAF detection: {e}")
    return None

def _match_fingerprint(response, fingerprint):
    for h_name, h_pattern in fingerprint.get('headers', {}).items():
        if h_name in response.headers and re.search(h_pattern, response.headers[h_name], re.IGNORECASE): return True
    for c_name, c_pattern in fingerprint.get('cookies', {}).items():
        if c_name in response.cookies and re.search(c_pattern, response.cookies[c_name], re.IGNORECASE): return True
    body_pattern = fingerprint.get('body')
    if body_pattern and re.search(body_pattern, response.text, re.IGNORECASE): return True
    return False

def get_ip_info(ip):
    try:
        url = f"http://ip-api.com/json/{ip}"
        response = requests.get(url, timeout=5)
        response.raise_for_status()
        data = response.json()
        if data.get('status') == 'success':
            return data.get('isp', data.get('org', 'N/A'))
        else:
            return "Private or Invalid Range"
    except requests.exceptions.RequestException:
        return "Could not fetch Whois info"

def find_ips_from_dns(domain, verbose=True):
    ips = set()
    try:
        resolver = dns.resolver.Resolver(); resolver.timeout = 2; resolver.lifetime = 2
        a_records = resolver.resolve(domain, 'A')
        for record in a_records:
            ips.add(record.to_text())
        if ips and verbose:
            print(f"[+] Found A Records for {domain}: {', '.join(ips)}")
    except (dns.resolver.NoAnswer, dns.resolver.NXDOMAIN, dns.resolver.NoNameservers, dns.exception.Timeout):
        pass
    except Exception as e:
        if verbose: print(f"[-] Error resolving {domain}: {type(e).__name__}")
    return list(ips)

def find_subdomains_from_crtsh(domain):
    subdomains = set([domain])
    headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'}
    url = f"https://crt.sh/?q=%.{domain}&output=json"
    
    print(f"\n--- [Subdomains] Searching for subdomains of {domain} via crt.sh ---")

    for attempt in range(3):
        try:
            response = requests.get(url, headers=headers, timeout=30)
            response.raise_for_status()
            
            for cert in response.json():
                for name in cert.get('name_value', '').split('\n'):
                    if name.endswith(f".{domain}") and not name.startswith('*.'):
                        subdomains.add(name.strip().lower())
            
            print(f"[+] Found {len(subdomains)} unique domain(s).")
            return list(subdomains)

        except (requests.exceptions.RequestException, json.JSONDecodeError) as e:
            print(f"[!] Attempt {attempt + 1} of 3 failed: {e}")
            if attempt < 2:
                print("[i] Retrying in 5 seconds...")
                time.sleep(5)
            else:
                print("[!] Subdomain search failed after 3 attempts.")
    
    return list(subdomains)

def find_historical_ips_from_viewdns(domain):
    ips = set()
    print(f"\n--- [History] Checking historical DNS for {domain} on ViewDNS.info ---")
    try:
        url = f"https://viewdns.info/iphistory/?domain={domain}"
        headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)'}
        response = requests.get(url, headers=headers, timeout=15)
        response.raise_for_status()
        soup = BeautifulSoup(response.text, "html.parser")
        tables = soup.find_all("table", {'border': '1'})
        if tables:
            for row in tables[0].find_all("tr")[1:]:
                cols = row.find_all("td")
                if cols and re.match(r'\b(?:\d{1,3}\.){3}\d{1,3}\b', cols[0].text.strip()):
                    ips.add(cols[0].text.strip())
            if ips:
                print(f"[+] Found {len(ips)} historical IP(s).")
    except requests.exceptions.RequestException as e:
        print(f"[!] Historical DNS check failed: {e}")
    return list(ips)

def process_subdomain(subdomain):
    """
    Processes one subdomain and returns a dictionary with its details and status.
    """
    ips = find_ips_from_dns(subdomain, verbose=False)
    
    if ips:
        status = "Active"
        waf_name = detect_waf(subdomain, verbose=False) or "None Detected"
        ip_str = ', '.join(ips)
    else:
        status = "Inactive"
        waf_name = "N/A"
        ip_str = "N/A"
        
    return {
        'status': status,
        'line': f"URL: {subdomain:<40} Status: {status:<10} WAF: {waf_name:<20} IP: {ip_str}"
    }

def find_original_ip(domain, stop_event):
    """
    Main function to find subdomains, process all of them, then print the
    results sorted into Active and Inactive groups.
    """
    MAX_WORKERS = 50 
    
    print("####################################################")
    print(f"### Starting Recon for: {domain.upper()} ###")
    print("####################################################")

    subdomains = find_subdomains_from_crtsh(domain)

    if stop_event.is_set():
        print("\n[!] Scan stopped by user.")
        return

    if subdomains:
        print(f"\n[i] Processing all {len(subdomains)} URLs... Please wait for the final report.")
        
        all_results = []
        with concurrent.futures.ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:
            future_to_subdomain = {executor.submit(process_subdomain, sub): sub for sub in subdomains}

            for future in concurrent.futures.as_completed(future_to_subdomain):
                if stop_event.is_set():
                    print("\n[!] Scan stopped by user. Halting processing.")
                    break
                try:
                    result_dict = future.result()
                    if result_dict:
                        all_results.append(result_dict)
                except Exception as exc:
                    subdomain = future_to_subdomain[future]
                    print(f"[-] An error occurred while processing {subdomain}: {exc}")

        if stop_event.is_set(): return

        active_urls = [res['line'] for res in all_results if res['status'] == 'Active']
        inactive_urls = [res['line'] for res in all_results if res['status'] == 'Inactive']

        print("\n\n####################################################")
        print(f"### Active URLs ({len(active_urls)}) ###")
        print("####################################################")
        if active_urls:
            for i, line in enumerate(active_urls, 1):
                print(f"{str(i) + '.':<4} {line}")
        else:
            print("[i] No active URLs found.")

        print("\n\n####################################################")
        print(f"### Inactive URLs ({len(inactive_urls)}) ###")
        print("####################################################")
        if inactive_urls:
            for i, line in enumerate(inactive_urls, 1):
                print(f"{str(i) + '.':<4} {line}")
        else:
            print("[i] No inactive URLs found.")


    if stop_event.is_set():
        return

    historical_ips = find_historical_ips_from_viewdns(domain)
    if historical_ips:
        print("\n\n####################################################")
        print(f"### Historical IP Summary for: {domain.upper()} ###")
        print("####################################################")
        for ip in historical_ips:
            owner = get_ip_info(ip)
            print(f"  -> Historical IP: {ip:<18} | Owner: {owner}")

    print("\n\n####################################################")
    print("### Scan Complete ###")
    print("####################################################")


# --- HEAVILY MODIFIED GUI Application Class ---
class App(ctk.CTk):
    def __init__(self):
        super().__init__()
        self.title("Domain Reconnaissance Tool")
        self.geometry("950x650") 
        ctk.set_appearance_mode("dark")

        # --- Splash Screen Setup ---
        self.splash_label = ctk.CTkLabel(self, text="Cyber Shanto", font=ctk.CTkFont(size=40, weight="bold"))
        self.splash_label.place(relx=0.5, rely=0.5, anchor="center")

        # Schedule the main UI to be built after 3 seconds
        self.after(3000, self.setup_main_ui)

    def setup_main_ui(self):
        """Destroys the splash screen and builds the main application widgets."""
        # Destroy the splash screen label
        self.splash_label.destroy()

        # --- Main Application UI ---
        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(2, weight=1)

        self.output_queue = queue.Queue()
        self.stop_event = threading.Event()
        self.log_file = None

        self.input_frame = ctk.CTkFrame(self)
        self.input_frame.grid(row=0, column=0, padx=10, pady=10, sticky="ew")
        self.input_frame.grid_columnconfigure(1, weight=1)

        self.label = ctk.CTkLabel(self.input_frame, text="Target Domain:")
        self.label.grid(row=0, column=0, padx=10, pady=10)

        self.domain_entry = ctk.CTkEntry(self.input_frame, placeholder_text="e.g., example.com")
        self.domain_entry.grid(row=0, column=1, padx=10, pady=10, sticky="ew")
        self.domain_entry.bind("<Return>", self.start_scan_event)

        self.start_button = ctk.CTkButton(self.input_frame, text="Start Scan", command=self.start_scan_event)
        self.start_button.grid(row=0, column=2, padx=(10, 5), pady=10)

        self.stop_button = ctk.CTkButton(self.input_frame, text="Stop Scan", command=self.stop_scan_event, state="disabled", fg_color="#D32F2F", hover_color="#B71C1C")
        self.stop_button.grid(row=0, column=3, padx=(0, 10), pady=10)

        self.status_label = ctk.CTkLabel(self, text="Enter a domain and click 'Start Scan'.")
        self.status_label.grid(row=1, column=0, padx=10, pady=(0, 5), sticky="w")

        self.output_textbox = ctk.CTkTextbox(self, state="disabled", text_color="#E5E5E5", font=("Courier New", 12))
        self.output_textbox.grid(row=2, column=0, padx=10, pady=(0, 10), sticky="nsew")
        
        # Start processing the queue for log output
        self.after(100, self.process_queue)

    def start_scan_event(self, event=None):
        domain = self.domain_entry.get().strip()
        if not domain:
            self.status_label.configure(text="Error: Domain cannot be empty.", text_color="orange")
            return
            
        self.stop_event.clear()
        self.start_button.configure(state="disabled")
        self.stop_button.configure(state="normal")
        self.domain_entry.configure(state="disabled")
        self.status_label.configure(text=f"Scanning {domain}...", text_color="#E5E5E5")
        
        self.output_textbox.configure(state="normal")
        self.output_textbox.delete("1.0", "end")
        self.output_textbox.configure(state="disabled")
        
        scan_thread = threading.Thread(target=self.run_scan_worker, args=(domain, self.stop_event), daemon=True)
        scan_thread.start()

    def stop_scan_event(self):
        self.status_label.configure(text="Stopping scan...", text_color="orange")
        self.stop_event.set()
        self.stop_button.configure(state="disabled")

    def process_queue(self):
        try:
            while True:
                line = self.output_queue.get_nowait()
                self.output_textbox.configure(state="normal")
                self.output_textbox.insert("end", line)
                self.output_textbox.see("end")
                self.output_textbox.configure(state="disabled")
        except queue.Empty:
            pass
        finally:
            self.after(200, self.process_queue)

    def run_scan_worker(self, domain, stop_event):
        output_filename = f"{domain}_recon_output.txt"
        try:
            with open(output_filename, 'w', encoding='utf-8') as f:
                gui_handler = QueueHandler(self.output_queue)
                tee_stream = Tee(sys.stdout, f, gui_handler)
                original_stdout = sys.stdout
                sys.stdout = tee_stream
                
                print(f"[i] All output is being saved to '{output_filename}'\n")
                find_original_ip(domain, stop_event)
                
        except Exception as e:
            print(f"\n[!!!] An unexpected error occurred in the scan worker: {e}")
        finally:
            sys.stdout = original_stdout
            self.after(0, self.scan_finished, output_filename)

    def scan_finished(self, filename):
        if self.stop_event.is_set():
            self.status_label.configure(text=f"Scan stopped by user. Log saved to '{filename}'.", text_color="orange")
        else:
            self.status_label.configure(text=f"Scan finished. Log saved to '{filename}'.", text_color="lightgreen")
            
        self.start_button.configure(state="normal")
        self.stop_button.configure(state="disabled")
        self.domain_entry.configure(state="normal")

if __name__ == "__main__":
    app = App()
    app.mainloop()